//暂时定义输出语句是printf("%s=%d%c",vars[i].c_str(),variables[vars[i]]," \n"[i == vars.size() - 1]);暂时禁止print()不带参。

/*
目前已实现：
1-声明变量(及声明并赋值)、(几乎)表达式全家桶(包括赋值的右结合特性、逗号运算符)、while循环、for循环、if语句、break和continue、函数支持参数和return一个表达式。
2-唯一入口为main，main无参。
3-支持空语句";"和空body，且支持这种写法：if(a<5)while(b<5)while(c<10){a+=1,b+=1;c+=2;}(即把下一个控制结构语句视为自身的";")
*/

/*
为了简化实现(我太菜了)，做如下约定：
1-入口只能为main,main无参。
2-声明变量和赋值可以同时完成了。
3-内置函数print不能出现在逗号表达式里，即必须单独成语句。如：if(...) print();是合法的。
4-所有循环暂不支持条件部分为空(懒得改了~)，即使已实现break。
5-变量和函数重名时,优先认为它是函数。十分不建议出现这种事情...
6-全局变量赋值时调用函数可能出现未定义行为...
*/
//
//已修复bug：
1-while循环内单句statement也应该开作用域。
2-支持空语句";"和空body，且支持这种写法：if(a<5)while(b<5)while(c<10){a+=1,b+=1;c+=2;}
3-forloop作用域需求：保留在init部分声明的变量,其余删除。我们改用一个Manager对象包办所有的作用域管理了。
4-stmts类需要初始化值，因为控制结构语句依赖它的返回值，若其数据仍然混乱，可能造成意外的return行为。
5-因为for、while的实现里，唯一出口忽略了stmts.cmd，无限循环里没有正常return。现已修复。
6-for、while循环在退出前多进行了1次条件检测，这是不应该的，将stmts.cmd的判定提前即可修复。

//未修复bug：
1-正常的输入代码莫名出现Expected variable but get token: f1，即parser运行不正常(怀疑是c++内存管理的问题?因为运行代码一定次数后才会出现这个bug...目前打了个析构函数以检测这种现象)